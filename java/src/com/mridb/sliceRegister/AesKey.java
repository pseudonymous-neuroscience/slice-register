package com.mridb.sliceRegister;

//import org.apache.commons.codec.binary.Hex;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;

import com.google.common.io.BaseEncoding;
import com.google.gson.Gson;
import com.google.gson.annotations.Expose;



/**
 * Obfuscates an AES key using a secret password.
 * The only thing that needs to be serialized is the salt.
 */
public class AesKey{

	private static Integer defaultIterationCount = 1000;
	private Integer iterationCount = null;
//	private static int iterationCount = 10000;
	public static int aesKeyLength = 128; // 256 is unsupported
	public static int rsaKeyLength = 4096;

	private String salt;

	private transient String passwordHash;
	private transient String secretPassword;
	private transient SecretKey secretKey;
//	private transient SecretKey secretKey;

	public static int getDefaultIterationCount() {
		return defaultIterationCount;
	}
	public int getIterationCount() {
		if(iterationCount == null) {
			return getDefaultIterationCount();
		}
		return iterationCount;
	}
	public String getSalt() {
		return this.salt;
	}
	public SecretKey getKey() throws Exception {
		if(this.secretKey == null) {
			throw new Exception("secret key must be set using setKey() or setPassword()");
		}
		return this.secretKey;
	}
	public void setKey(SecretKey key) {
		this.secretKey = key;
	}


	/** Creates a new AesKey with a random salt
	 * @param password - the secret password
	 */
	public AesKey(String password) {
		this(password, generateSalt());		
	}

	/** Attempts to re-create an existing AesKey by hashing the password with a salt
	 * @param password - the secret password
	 * @param salt - the only stored value, used with the password to generate the key
	 */
	public AesKey(String password, String salt) {
		this.salt = salt;
		this.setPassword(password);
	}
	
	public void setPassword(String password) {
		boolean isNewPassword = false;
		if(this.secretPassword == null) {
			isNewPassword = true;
		}else {
			if(!this.secretPassword.equals(password)) {
				isNewPassword = true;
			}
		}
		if(isNewPassword) {
			this.secretKey = generateSecretKey(password, salt, this.getIterationCount());
			byte[] hashBytes = secretKey.getEncoded();
			this.passwordHash = Util.toBase64(hashBytes);
		}
	}
	
	public static AesKey deserialize(String serialized) {
		Gson gson = new Gson();
		AesKey key = gson.fromJson(serialized, AesKey.class);
		return key;
	}


	/** Generates a random salt to be used in password hashes
	 * @return a block of 32 bytes 
	 */
	public static String generateSalt() {
		SecureRandom rand = new SecureRandom();
		byte[] salt = new byte[32];
		rand.nextBytes(salt);		
//		return Util.toBase64(salt);
		return BaseEncoding.base64().omitPadding().encode(salt);
	}


	/** Saves salt to be used with the secret password so that key can be re-generated
	 *
	 */
	public String toString() {
		Gson gson = new Gson();
		return gson.toJson(this);
	}


	/** Generates a secret key based on the password and salt
	 * @param password - secret password
	 * @param salt - randomly generated bytes, base64 encoded
	 * @return - the AES secret key
	 */
	public static SecretKey generateSecretKey( final String password, final String salt, int iterationCount) {
		char[] passChar = password.toCharArray();
		//		byte[] saltByte = Util.fromBase64(salt);
		byte[] saltByte = BaseEncoding.base64().omitPadding().decode(salt);
		return generateSecretKey(passChar, saltByte, iterationCount);
	}

	/** Generates a secret key based on the password and salt
	 * @param password - secret password
	 * @param salt - randomly generated bytes
	 * @return - the AES secret key
	 */
	public static SecretKey generateSecretKey( final char[] password, final byte[] salt, int iterationCount) {
//		int keyLength = 128;
		int keyLength = AesKey.aesKeyLength;
		String algName = "AES";
		//		if(!isAes) {
		//			keyLength = 4096;
		//			algName = "RSA";
		//		}

		try {
			SecretKeyFactory skf = SecretKeyFactory.getInstance( "PBKDF2WithHmacSHA512" );
			PBEKeySpec spec = new PBEKeySpec( password, salt, iterationCount, keyLength );

			SecretKey tmp = skf.generateSecret( spec );
			SecretKey key = new SecretKeySpec(tmp.getEncoded(), algName);
			return key;
		} catch ( NoSuchAlgorithmException | InvalidKeySpecException e ) {
			throw new RuntimeException( e );
		}
	}

	/**
	 * @param Encrypts a String using AES
	 * @return an EncryptedString, which includes a random initialization vector
	 * @throws Exception 
	 */
	@SuppressWarnings("unused")
	private EncryptedBytes encrypt(String plainText) throws Exception {
		assertKeyIsSet();

//		EncryptedString encrypted = new EncryptedString(this.secretKey);
		EncryptedBytes encrypted = new EncryptedBytes(plainText, this.secretKey);
		encrypted.setPlainText(plainText);
		//		return encrypted.getCipherText();
		return encrypted;
	}
	@SuppressWarnings("unused")
	private EncryptedBytes encrypt(byte[] plainBytes) throws Exception {
		assertKeyIsSet();

//		EncryptedString encrypted = new EncryptedString(this.secretKey);
		EncryptedBytes encrypted = new EncryptedBytes(plainBytes, this.secretKey);
		encrypted.setPlainText(plainBytes);
		//		return encrypted.getCipherText();
		return encrypted;
	}
	
	private static int fileBufferSize = 1024 * 1024;
	
	public byte[] encryptFile(String inputFilePath, String outputFilePath) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
		FileInputStream inputFileStream = new FileInputStream(inputFilePath);
		FileOutputStream outFileStream = new FileOutputStream(outputFilePath);
		byte[] ivBytes = new byte[this.aesKeyLength / 8];
		SecureRandom.getInstanceStrong().nextBytes(ivBytes);
		IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);
		Cipher cipher;
		cipher = Cipher.getInstance(EncryptedBytes.algName);
		cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);
		CipherOutputStream outputStream = new CipherOutputStream(outFileStream, cipher);
		byte[] buffer = new byte[fileBufferSize];
		boolean finished = false;
		while(!finished) {
			int bytesRead = inputFileStream.read(buffer);
			if(bytesRead == -1) {
				finished = true;
			} else if(bytesRead == fileBufferSize) {
				outputStream.write(buffer);
			} else {
				byte[] remaining = Arrays.copyOf(buffer, bytesRead);
				outputStream.write(remaining);
			}
		}
		inputFileStream.close();
		outputStream.close();
		return ivBytes;
	}
	
	public void decryptFile(String inputFilePath, String outputFilePath, byte[] initializationVector) throws NoSuchAlgorithmException, NoSuchPaddingException, IOException, InvalidKeyException, InvalidAlgorithmParameterException {
		FileInputStream inputFileStream = new FileInputStream(inputFilePath);
		FileOutputStream outFileStream = new FileOutputStream(outputFilePath);
//		byte[] ivBytes = new byte[this.aesKeyLength / 8];
//		SecureRandom.getInstanceStrong().nextBytes(ivBytes);
		IvParameterSpec ivSpec = new IvParameterSpec(initializationVector);
		Cipher cipher;
		cipher = Cipher.getInstance(EncryptedBytes.algName);
		cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);
		CipherOutputStream outputStream = new CipherOutputStream(outFileStream, cipher);
		byte[] buffer = new byte[fileBufferSize];
		boolean finished = false;
		while(!finished) {
			int bytesRead = inputFileStream.read(buffer);
			if(bytesRead == -1) {
				finished = true;
			} else if(bytesRead == fileBufferSize) {
				outputStream.write(buffer);
			} else {
				byte[] remaining = Arrays.copyOf(buffer, bytesRead);
				outputStream.write(remaining);
			}
		}
		inputFileStream.close();
		outputStream.close();
	}
	
	
	/** Decrypts the EncryptedString, filling in our own AesKey
	 * @param encrypted - an object containing both the cipherText and initializationVector
	 * @return the plainText
	 * @throws Exception 
	 */
//	private String decrypt(EncryptedString encrypted) throws Exception {
//		assertKeyIsSet();
//		return this.decrypt(encrypted.getCipherText(), encrypted.getInitializationVector(), encrypted.getLength());
//	}


	/** Decrypts the string using the supplied IV and our own key
	 * @param cipherText - the encrypted text
	 * @param initializationVector - saved alongside the cipherText in JSON
	 * @return - the plainText
	 * @throws Exception 
	 */
	@SuppressWarnings("unused")
	private String decrypt(String cipherText, String initializationVector, int length) throws Exception {
//		assertPasswordIsSet();
		SecretKey key = this.getKey();
		EncryptedString encrypted = new EncryptedString(key, initializationVector);
		encrypted.setCipherText(cipherText, length);
		String plainText = encrypted.getPlainText();
		return plainText;
	}
//	private byte[] decrypt(EncryptedBytes cipherBytes) throws Exception {
////		SecretKey key = this.getKey();
//		this.set
//		return cipherBytes.decrypt(key);
//
//	}
//	private byte[] decrypt(byte[] cipherBytes, String initializationVector, int length, int iterationCount) throws Exception {
//		//		assertPasswordIsSet();
//		SecretKey key = this.getKey();
//		//		EncryptedString encrypted = new EncryptedString(key, initializationVector);
//		//		encrypted.setCipherText(cipherText, length);
//		//		EncryptedBytes bytes = new EncryptedBytes();
//		byte[] plainBytes = EncryptedBytes.decrypt(cipherBytes, key, initializationVector, length);
//		EncryptedBytes bytes = new EncryptedBytes("", initializationVector, length, iterationCount);
//
//		return plainBytes;
//
//	}
	

	
	public void assertKeyIsSet() throws Exception {
		if(!isKeySet()) {
			throw new java.lang.Exception("attempted to use aesKey before secret key was set");
		}
	}

	public boolean isKeySet() {
		if(this.secretKey == null) {
			return false;
		}
		return true;
	}

	

	public static void main(String[] args) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IOException {
		
		String testInputFilePath = "/home/neuro/octaveServerContainerInspect.txt";
		String testEncryptedFilePath = "/home/neuro/octaveServerContainerInspectEncrypted.txt";
		String testDecryptedFilePath = "/home/neuro/octaveServerContainerInspectDecrypted.txt";

		String password = "pass";
		long start = System.currentTimeMillis();
		AesKey key1 = new AesKey(password); 
		String key1String = key1.toString();
		AesKey key2 = AesKey.deserialize(key1String);
		//		PasswordProtectedKey key2 = new PasswordProtectedKey(password); 
		//		PasswordProtectedKey key3 = new PasswordProtectedKey(password, key1.salt); 
		
		byte[] iv = key1.encryptFile(testInputFilePath, testEncryptedFilePath);
		key1.decryptFile(testEncryptedFilePath, testDecryptedFilePath, iv);
		
		String inputHash = FileHasher.hashFile(testInputFilePath);
		String decryptedputHash = FileHasher.hashFile(testDecryptedFilePath);
		boolean isMatch = inputHash.contentEquals(decryptedputHash);

		long finish = System.currentTimeMillis();
		System.out.println(key1.toString());
		//		System.out.println(key2.toString());
		//		System.out.println(key3.toString());

		System.out.println("elapsed time: " + (finish - start));
	}


}
